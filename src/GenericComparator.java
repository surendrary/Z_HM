
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Comparator;
import java.util.Date;


/**
 * This class represents GenericComparator Implementation.
 */
public class GenericComparator implements Comparator{
	
	private static final int LESS = -1;
	private static final int EQUAL = 0;
	private static final int GREATER = 1;
	private static final String TYPE_STRING = "java.lang.String";
	private static final String TYPE_DATE = "java.util.Date";
	private static final String TYPE_INTEGER = "java.lang.Integer";
	private static final String TYPE_LONG = "java.lang.Long";
	private static final String TYPE_FLOAT = "java.lang.Float";
	private static final String TYPE_DOUBLE = "java.lang.Double";
    private static final String GETTER_METHOD_PREFIX = "get";
	private enum CompareType { EQUAL, LESS_THAN, GREATER_THAN, DEFAULT }

	private String methodName;
	private boolean sortAscending;

	/**
     * Constructor with parameters
     * @param sortField
     * @param sortAscending
     */

	public GenericComparator(String sortField, boolean sortAscending) {
		super();
		this.methodName = getMethodName(sortField);
		this.sortAscending = sortAscending;
	}

	@Override
	public int compare(Object o1, Object o2) {
		int response = LESS;
		try {
			Object v1 = (this.methodName == null) ? o1 : getValue(o1);
			Object v2 = (this.methodName == null) ? o2 : getValue(o2);
            CompareType cm = getCompareType(v1, v2);

			if (!cm.equals(CompareType.DEFAULT)) {
				return compareWithNull(cm);
			}

			final String returnType = (this.methodName ==null) ? o1.getClass().getName() : getMethod(o1).getReturnType().getName();
			response = compareWithoutNull(v1, v2, returnType);
		} catch (Exception e) {

			e.printStackTrace();
		}

		return response;
	}
    /**
     * Setting compare Type based on Object is null or not
     * @return CompareMode
     */
    private CompareType getCompareType(Object o1, Object o2) {
        CompareType cm = CompareType.LESS_THAN;

        if(o1 != null & o2 != null) {
            cm = CompareType.DEFAULT;
        } else if (o1 == null & o2 != null) {
            cm = CompareType.LESS_THAN;
        } else if (o1 != null & o2 == null) {
            cm = CompareType.GREATER_THAN;
        } else if (o1 == null & o2 == null) {
            cm = CompareType.EQUAL;
        }

        return cm;
    }



    /**
     * Comparison Method if any one value id null
     *
     * @param cm - enum to find position in sorted list.
     */
	private int compareWithNull(CompareType cm) {
		int compareState = LESS;
		switch(cm) {
			case LESS_THAN:
				compareState = LESS * sortingPosition();
				break;
			case GREATER_THAN:
				compareState = GREATER * sortingPosition();
				break;
			case EQUAL:
				compareState = EQUAL * sortingPosition();
				break;
		}
		return compareState;
	}

    /**
     * Comparison method id both values and not null.
     *
     * @param v1 - value of Object1
     * @param v2 - value of Object2
     * @param returnType - datatype of given values
     * @return int - compare return value
     */

	private int compareWithoutNull(Object v1, Object v2, String returnType) {
		int actual = LESS;
		if (returnType.equals(TYPE_INTEGER)) {
			actual = (((Integer) v1).compareTo((Integer) v2) * sortingPosition());
		} else if (returnType.equals(TYPE_LONG)) {
			actual = (((Long) v1).compareTo((Long) v2) * sortingPosition());
		} else if (returnType.equals(TYPE_STRING)) {
			actual = (((String) v1).compareTo((String) v2) * sortingPosition());
		} else if (returnType.equals(TYPE_DATE)) {
			actual = (((Date) v1).compareTo((Date) v2) * sortingPosition());
		} else if (returnType.equals(TYPE_FLOAT)) {
			actual = (((Float) v1).compareTo((Float) v2) * sortingPosition());
		} else if (returnType.equals(TYPE_DOUBLE)) {
			actual = (((Double) v1).compareTo((Double) v2) * sortingPosition());
		}
		return actual;
	}

    /**
     * Generation of getter Method Name from Home Class based onf sortField.
     *
     * @param  - sortFieldName - value of sortFieldName
     * @return Getter method name
     */
	private final static String getMethodName(String name) {
		StringBuffer fieldName =  new StringBuffer(GETTER_METHOD_PREFIX);
		fieldName.append(name.substring(0, 1).toUpperCase());
		fieldName.append(name.substring(1));
		return fieldName.toString();
	}

    /**
     * Getting Method Object using Java Reflect
     * @param obj
     * @return method object
     */
	private final Method getMethod(Object obj) throws NoSuchMethodException {
		return obj.getClass().getMethod(methodName, null);
	}

    /**
     * Calling method using method Object generated by reflect
     * @return int - Object of given method
     */
	private final static Object invoke(Method method, Object obj) throws InvocationTargetException, IllegalAccessException {
		return method.invoke(obj, null);
	}


    /**
     * Getting the value from object
     * @return Object
     */
	private Object getValue(Object obj) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
		return invoke(getMethod(obj), obj);
	}

    /**
     * Identify position of of objects in sorted list
     *
     */
	private int sortingPosition() {
		return sortAscending ? GREATER : LESS;
	}
}
